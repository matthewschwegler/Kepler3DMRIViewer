/*
 * Copyright (c) 2003-2010 The Regents of the University of California.
 * All rights reserved.
 *
 * '$Author: crawl $'
 * '$Date: 2012-10-31 12:17:43 -0700 (Wed, 31 Oct 2012) $' 
 * '$Revision: 30996 $'
 * 
 * Permission is hereby granted, without written agreement and without
 * license or royalty fees, to use, copy, modify, and distribute this
 * software and its documentation for any purpose, provided that the above
 * copyright notice and the following two paragraphs appear in all copies
 * of this software.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 * THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 * PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 * CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 * ENHANCEMENTS, OR MODIFICATIONS.
 *
 */

package org.kepler.objectmanager.lsid;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.kepler.configuration.ConfigurationManager;
import org.kepler.configuration.ConfigurationProperty;
import org.kepler.util.AuthNamespace;
import org.kepler.util.sql.DatabaseFactory;
import org.kepler.util.sql.DatabaseType;

import ptolemy.util.MessageHandler;

/**
 * This class maintains a list of LSIDs in the system and can generate new LSIDs
 * that are unique to the local system. 
 *
 *@created June 20, 2005
 */

public class LSIDGenerator {
    
	private static final Log log = LogFactory.getLog(LSIDGenerator.class
			.getName());
	private static final boolean isDebugging = log.isDebugEnabled();

	// singleton instance
	private static LSIDGenerator generator = null;

	/** The AuthNamespace object. */
	private AuthNamespace _authNamespace;

	/** The name of the lsid generator table. */
	private static final String LSID_GENERATOR_TABLE_NAME = "LSID_GENERATOR";

	/** SQL to create the lsid generator table.
	 *  
	 *  FIXME convert to org.kepler.util.sql.Schema to support non-HSQL dbs
	 *  
	 *  The LSID_GENERATOR table is used to record the highest Revision for an
	 *  object ID that has been generated by this Kepler instance for a specific
	 *  authority and namespace.
     *      AUTH - the Authority
     *      NS - the NameSpace
     *      OID - the highest Object ID assigned by this Kepler instance
     *      REV - the highest Revision assigned by this Kepler instance
     */
	 private static final String LSID_GENERATOR_TABLE_CREATE_SQL =
	     "create cached table LSID_GENERATOR (AUTH varchar, NS varchar, " +
	     "OID bigint, REV bigint, PRIMARY KEY (AUTH,NS,OID) )";

	/** The database. */
	private static DatabaseType _dbType;
	
	/**
	 * Convenience reference. Make sure to close your ResultSets since we're
	 * reusing the Statement.
	 */
	private static Statement _stmt;
	
	private static PreparedStatement _insertPrepStmt;
	private static PreparedStatement _updatePrepStmt;
	
	/** The name of the database. */
	public static final String CORE_DB_STR = "coreDB";
	
	/** Builds a new instance of the LSIDGenerator. NOTE: the
	 *  constructor is private so that only one instance may be created.
	 */
    private LSIDGenerator() throws Exception {
        
        openDatabase();
        
        // Every time we get a new connection to the LSID_GENERATOR
        // table, check it to make sure the current AuthorizedNamespace
        // has at least one row in it, if it does not, get a new
        // AuthorizedNamespace (this means the LSID_GENERATOR table was
        // deleted somehow
        int rows = countRowsForCurrentAuthNamespace();
        if (rows <= 0) {
            AuthNamespace an = AuthNamespace.getInstance();
            an.getNewAuthorizedNamespace();
        }

        _authNamespace = AuthNamespace.getInstance();

	}
	
	/**
	 * returns a singleton instance of this class
	 */
	public static synchronized LSIDGenerator getInstance() {
		if (generator == null) {
			try {
				generator = new LSIDGenerator();
			} catch (Exception e) {
			    MessageHandler.error("Error creating LSID generator.", e);
			}
		}
		return generator;
	}

	/**
	 * Return a new LSID using the Authority and Namespace for this Kepler
	 * Instance and the NextObjectID for this instance with a revision number of
	 * 1.
	 * 
	 * @return a new KeplerLSID that is globally unique
	 * @throws Exception
	 */
	public KeplerLSID getNewLSID() throws Exception {
		if (isDebugging)
			log.debug("getNewLSID()");

		KeplerLSID lsid = null;

		Long nextObjectID = getNextObjectID();

		lsid = new KeplerLSID(_authNamespace.getAuthority(), _authNamespace
                .getNamespace(), nextObjectID, Long.valueOf(1));
		
		boolean success = recordLsidGeneration(lsid);
		if (success) {
			if (isDebugging)
				log.debug("newLSID: " + lsid);
			return lsid;
		}
		return null;
	}
	
	/**
	 * Update the revision of a KeplerLSID.
	 * 
	 * @param lsid
	 * @return
	 */
	public KeplerLSID updateLsidRevision(KeplerLSID lsid) {
		if (isDebugging)
			log.debug("updateLsidRevision("+lsid.toString()+")");
		
		if ( !lsid.getAuthority().equals(_authNamespace.getAuthority()) 
				|| !lsid.getNamespace().equals(_authNamespace.getNamespace())) {
			return null;
		}
		
		try {
			Long lastRevision = null;

			// FIXME make a prepared statement
			String query = "select REV from " + LSID_GENERATOR_TABLE_NAME
				+ " where auth = '" + lsid.getAuthority() + "' "
				+ " and ns = '" + lsid.getNamespace() + "' "
				+ " and oid = " + lsid.getObject();
			if (isDebugging) log.debug(query);
			ResultSet rs = null;
            try {
                rs = _stmt.executeQuery(query);
                if (rs == null)
                    throw new SQLException("Query Failed: " + query);
                if (rs.next()) {
                    lastRevision = rs.getLong(1);
                    if (rs.wasNull())
                        throw new SQLException("Last Revision was Null");
                    if (rs.next())
                        throw new SQLException(LSID_GENERATOR_TABLE_NAME
                                + " table is corrupt");
                }
            } finally {
                if (rs != null) {
                    rs.close();
                }
            }
			
            // FIXME lastRevision could be null
			lsid.setRevision(lastRevision + 1L);

			_updatePrepStmt.setLong(1, lsid.getRevision());
			_updatePrepStmt.setString(2, lsid.getAuthority());
			_updatePrepStmt.setString(3, lsid.getNamespace());
			_updatePrepStmt.setLong(4, lsid.getObject());
			_updatePrepStmt.executeUpdate();
			_updatePrepStmt.clearParameters();
			
			//_conn.commit();
			
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return lsid;
		
	}
	
	/**
	 * Record the generation of a new LSID in the LSID_GENERATOR table.
	 * 
	 * @param lsid
	 * @return
	 */
	private boolean recordLsidGeneration(KeplerLSID lsid) {
        if (isDebugging)
            log.debug("recordLsidGeneration(" + lsid.toString() + ")");
        boolean success = false;

        try {
            insertRow(lsid.getAuthority(), lsid.getNamespace(), lsid
                    .getObject(), lsid.getRevision());
            success = true;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return success;
    }
	
	/** Insert a row into the LSID generator table. */
	public static void insertRow(String authority, String namespace,
            long object, long revision) throws Exception {
	    
	    // since this method is static, make sure the database has
	    // been opened and prepared statements created.
	    if(_dbType == null) {
	        openDatabase();
	    }
	    
        try {
            _insertPrepStmt.clearParameters();
            _insertPrepStmt.setString(1, authority);
            _insertPrepStmt.setString(2, namespace);
            _insertPrepStmt.setLong(3, object);
            _insertPrepStmt.setLong(4, revision);
            _insertPrepStmt.executeUpdate();
        } catch (SQLException e) {
            throw new Exception("Error inserting into lsid generator table: "
                    + e.getMessage());
        }
    }
	
	/** Open the database containing the lsid generator table and intialize
	 *  prepared statements.
	 */
	private static void openDatabase() throws Exception
	{
	    if(_dbType == null)
	    {
	        ConfigurationManager configManager = ConfigurationManager.getInstance();
	        ConfigurationProperty coreProperty = configManager
	                .getProperty(ConfigurationManager.getModule("core"));
	        ConfigurationProperty coreDBProperty = coreProperty
	                .getProperty(CORE_DB_STR);

	        if (coreDBProperty == null) {
	            throw new Exception("Could not find " + CORE_DB_STR
	                    + " in core module's configuration.xml.");
	        }

	        _dbType = DatabaseFactory.getConnectedDatabaseType(coreDBProperty);

	        // By creating the statement and keeping it around
	        // make sure to close your resultsets to save memory
	        _stmt = _dbType.getStatement();

	        // create lsid generator table if it does not exist.
	        if(!_dbType.tableExists(LSID_GENERATOR_TABLE_NAME))
	        {
	            _stmt.execute(LSID_GENERATOR_TABLE_CREATE_SQL);
	        }

	        _insertPrepStmt = _dbType.getPrepStatement("insert into "
	                + LSID_GENERATOR_TABLE_NAME
	                + " (AUTH,NS,OID,REV) values (?,?,?,?)");
	        _updatePrepStmt = _dbType.getPrepStatement("update "
	                + LSID_GENERATOR_TABLE_NAME + " SET REV=? "
	                + " WHERE AUTH=? and NS=? and OID=?");
	    }
	}

	/**
	 * Return the next available Object ID for the current authority and namespace.
	 * 
	 * @throws Exception
	 */
	private Long getNextObjectID() throws Exception {
		if (isDebugging)
			log.debug("getNextObjectID()");

		Long nextOID = null;
		
        // FIXME make a prepared statement
		String query = "select max(OID) from " + LSID_GENERATOR_TABLE_NAME
			+ " where auth = '" + _authNamespace.getAuthority() + "' "
			+ " and ns = '" + _authNamespace.getNamespace() + "'";
		if (isDebugging) log.debug(query);
		ResultSet rs = null;
		try {
            rs = _stmt.executeQuery(query);
            if (rs == null)
                throw new SQLException("Query Failed: " + query);
            if (rs.next()) {
                Long maxOID = rs.getLong(1);
                nextOID = maxOID + 1L;
            } else {
                nextOID = 1L;
            }
        } finally {
            if (rs != null) {
                rs.close();
            }
        }
		
		if (nextOID != null && nextOID > 0) {
			if (isDebugging) {
				log.debug("LastObjectID: " + nextOID);
			}
			return nextOID;
		}
		return null;
	}
	
	/**
	 * Return the number of rows in the LSID_GENERATOR table.
	 * 
	 * @return int number of rows in the LSID_GENERATOR table
	 */
	public int countRowsForCurrentAuthNamespace() {
		int cnt = -1;
		try {
			AuthNamespace an = AuthNamespace.getInstance();
		
	        // FIXME make a prepared statement
			String query = "select count(*) from " + LSID_GENERATOR_TABLE_NAME;
			query += " where AUTH = '" + an.getAuthority() 
				+ "' and NS = '" + an.getNamespace() + "'";
			if (isDebugging) log.debug(query);
			ResultSet rs = null;
			try {
                rs = _stmt.executeQuery(query);
                if (rs == null)
                    throw new SQLException("Query Failed: " + query);
                if (rs.next()) {
                    cnt = rs.getInt(1);
                    if (rs.wasNull()) {
                        cnt = -1;
                    }
                    if (rs.next()) {
                        cnt = -1;
                        throw new SQLException("Should never happen");
                    }
                }
            } finally {
                if (rs != null) {
                    rs.close();
                }
            }
		} catch (SQLException sqle) {
			System.out.println(sqle.getMessage());
			sqle.printStackTrace();
		}
		return cnt;
	}
	
	/** Close the LSID database if opened. */
	public static void closeDatabase() {
	    if(_dbType != null) {
	        
	        try {
                _stmt.close();
            } catch (SQLException e) {
                MessageHandler.error("Error closing database statement.", e);
            }
	        
	        try {
                _dbType.disconnect();
            } catch (SQLException e) {
                MessageHandler.error("Error closing LSID database.", e);
            }
	        _dbType = null;
	        generator = null;
	    }
	}
}