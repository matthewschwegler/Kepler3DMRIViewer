<?xml version="1.0"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="ConvolutionalCoder" class="ptolemy.kernel.ComponentEntity">
<property name="entityId"  value="urn:lsid:kepler-project.org:actor:647:1" class="org.kepler.moml.NamedObjId"/>
<property name="class" value="ptolemy.actor.lib.comm.ConvolutionalCoder" class="ptolemy.kernel.util.StringAttribute">
  <property name="id" value="null" class="ptolemy.kernel.util.StringAttribute"/>
</property>

<property name="uncodedRate" class="ptolemy.data.expr.Parameter" value="1">
</property>

<property name="polynomialArray" class="ptolemy.data.expr.Parameter" value="{05, 07}">
</property>

<property name="initialState" class="ptolemy.data.expr.Parameter" value="0">
</property>

<property name="semanticType00" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:2:1#Communications">
</property>

<property name="kepler:input" class="org.kepler.moml.PortAttribute">
  <property name="direction" value="input" class="ptolemy.kernel.util.StringAttribute"/>
  <property name="dataType" value="boolean" class="ptolemy.kernel.util.StringAttribute"/>
  <property name="isMultiport" value="false" class="ptolemy.kernel.util.StringAttribute"/>
</property>
<property name="kepler:output" class="org.kepler.moml.PortAttribute">
  <property name="direction" value="output" class="ptolemy.kernel.util.StringAttribute"/>
  <property name="dataType" value="boolean" class="ptolemy.kernel.util.StringAttribute"/>
  <property name="isMultiport" value="false" class="ptolemy.kernel.util.StringAttribute"/>
</property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Ye Zhou, contributor: Edward A. Lee</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>$Id: ConvolutionalCoder.java 57040 2010-01-27 20:52:32Z cxh $</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;Encode an input sequence with a convolutional code. The inputs and&#10; outputs are booleans. The input sequence&#10; enters a shift register, and the contents of the shift register are&#10; combined using boolean functions given by the &lt;i&gt;polynomialArray&lt;/i&gt;&#10; parameter. The initial state of the shift register is given by the&#10; &lt;i&gt;initialState&lt;/i&gt; parameter, which should be a non-negative integer.&#10; The &lt;i&gt;uncodedRate&lt;/i&gt; parameter, often denoted by &lt;i&gt;k&lt;/i&gt; in the&#10; coding literature, is the number of bits per firing that are shifted&#10; into the shift register. The &lt;i&gt;polynomialArray&lt;/i&gt; parameter is an&#10; array of positive integers. Each integer indicates one polynomial&#10; used for computing output bits. To get a &lt;i&gt;k&lt;/i&gt;/&lt;i&gt;n&lt;/i&gt;&#10; convolutional code, set &lt;i&gt;uncodedRate&lt;/i&gt; to &lt;i&gt;k&lt;/i&gt; and provide&#10; &lt;i&gt;n&lt;/i&gt; integers in &lt;i&gt;polynomialArray&lt;/i&gt;.&#10; &lt;p&gt;&#10; The integers in &lt;i&gt;polynomialArray&lt;/i&gt; are usually most conveniently&#10; given as octal numbers. A leading zero indicates an octal&#10; number. The &lt;i&gt;i&lt;/i&gt;-th bit of the integer indicates whether the&#10; &lt;i&gt;i&lt;/i&gt;-th tap of the delay line should be used.  All bits that&#10; are used are exclusive-ored, thus yielding the parity of the selected&#10; bits. See more details in Scrambler actor on using an integer to&#10; define a polynomial. The &lt;i&gt;n&lt;/i&gt; parity results are produced on&#10; the output in a sequence.&#10; &lt;p&gt;&#10; A good convolutional code should have large Hamming distance between&#10; any two of its codewords. This is not easily checked, but there are some&#10; simple rules that all &quot;good&quot; codes should satisfy:&#10; &lt;ol&gt;&#10; &lt;li&gt; &lt;i&gt;k&lt;/i&gt; should be strictly smaller than &lt;i&gt;n&lt;/i&gt;, otherwise&#10; the code is not uniquely decodable.  Thus, &lt;i&gt;uncodedRate&lt;/i&gt;&#10; should be less than the length of &lt;i&gt;polynomialArray&lt;/i&gt;.&#10; &lt;li&gt; &lt;i&gt;k&lt;/i&gt; should not be higher than the highest order of&#10; all polynomials, otherwise, some input bits never get&#10; involved in computing parities.&#10; &lt;/ol&gt;&#10; If these rules are violated, the actor will throw an exception.&#10; However, these rules do not guarantee the codeword can be decoded&#10; successfully, and it is not always true that larger polynomials&#10; yield better codes. Users should check tables for convolutional&#10; codes from professional references. For convenience, we list here&#10; some convolutional codes that have large distance property.&#10; &lt;pre&gt;&#10; Rate = 1/2&#10; polynomialArray&#10; {05, 07}&#10; {013, 017}&#10; {031, 027}&#10; {065, 057}&#10; {0155, 0117}&#10; &lt;p&gt;&#10; Rate = 1/3&#10; polynomialArray&#10; {05, 07, 07}&#10; {015, 013, 017}&#10; {025, 033, 037}&#10; {071, 065, 057}&#10; {0155, 0123, 0137}&#10; &lt;p&gt;&#10; Rate = 1/4&#10; polynomialArray&#10; {05, 07, 07, 07}&#10; {015, 013, 013, 017}&#10; {025, 035, 033, 037}&#10; {065, 073, 047, 057}&#10; {0135, 0135, 0163, 0147}&#10; &lt;p&gt;&#10; Rate = 1/5&#10; polynomialArray&#10; {07, 07, 07, 05, 05}&#10; {017, 017, 015, 013, 013}&#10; {037, 035, 033, 025, 027}&#10; {057, 047, 067, 053, 075}&#10; &lt;p&gt;&#10; Rate = 1/6&#10; polynomialArray&#10; {07, 07, 07, 07, 05, 05}&#10; {017, 017, 015, 015, 013, 013}&#10; {037, 027, 035, 033, 025, 027}&#10; {067, 057, 055, 053, 071, 075}&#10; &lt;p&gt;&#10; Rate = 2/3&#10; polynomialArray&#10; {017, 06, 013}&#10; {072, 057, 027}&#10; {0171, 0166, 0273}&#10; &lt;p&gt;&#10; Rate = k/5&#10; k     polynomialArray&#10; 2     {017, 016, 011, 05, 02}&#10; 2     {072, 047, 025, 053, 075}&#10; 3     {056, 062, 057, 043, 071}&#10; &lt;p&gt;&#10; Rate = k/7&#10; k     polynomialArray&#10; 2     {012, 06, 05, 013, 013, 015, 017}&#10; 2     {066, 055, 027, 071, 052, 056, 057}&#10; 3     {051, 042, 036, 023, 075, 061, 047}&#10; &lt;p&gt;&#10; Rate  polynomialArray&#10; 3/4   {064, 052, 043, 071}&#10; 3/8   {054, 021, 062, 043, 045, 036, 057, 071}&#10; &lt;/pre&gt;&#10; &lt;p&gt;&#10; Note that this implementation is limited to a shift register&#10; length of 32 because of the specification of the polynomials and&#10; initial shift register state as 32-bit integers.&#10; &lt;p&gt;&#10; For more information on convolutional codes, see Proakis, Digital&#10; Communications, Fourth Edition, McGraw-Hill, 2001, pp. 471-477,&#10; or Barry, Lee and Messerschmitt, &lt;i&gt;Digital Communication&lt;/i&gt;, Third Edition,&#10; Kluwer, 2004.&#10; &lt;p&gt;</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The output port. By default, the type of this output is constrained  to be at least that of the input.</configure></property>
<property name="port:input" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The input port.  This base class imposes no type constraints except  that the type of the input cannot be greater than the type of the  output.</configure></property>
<property name="prop:uncodedRate" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Integer defining the number of bits that the shift register  takes in each firing. It should be a positive integer. Its  default value is the integer 1.</configure></property>
<property name="prop:initialState" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Integer defining the initial state of the shift register.  The i-th bit of the integer indicates the value of the  i-th register. This parameter should be a non-negative  integer. Its default value is the integer 0.</configure></property>
<property name="prop:polynomialArray" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An array of integers defining an array of polynomials with  binary coefficients. The coefficients indicate the presence (1)  or absence (0) of a tap in the shift register. Each element  of this array parameter should be a positive integer.  The default value is {05, 07}.</configure></property>
</property></entity>
